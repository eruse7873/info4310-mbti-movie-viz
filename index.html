<html lang="en">

<head>
    <title>MBTI</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        .display {
            display: flex;
            justify-content: space-between;
            height: 300px;
            width: 600;
            margin-left: 10px;
            margin-right: 10px;
        }


        .individual {
            align-self: center;
            padding: 3px;
            border: 3px solid transparent;
        }

        .individual:hover {
            border: 3px solid rgb(190, 190, 190)
        }

        .individual img {
            cursor: pointer;
        }

        .individual:last-child {
            margin-right: 100;
        }

        .avatar_selector {
            height: 300px;
            width: 550px;
            display: flex;
        }


        .hidden {
            display: none;
        }

        .gridlines .domain {
            display: none;
        }

        .contains_triangle {
            align-self: center;
        }

        .triangle {
            cursor: pointer;
            padding-left: 50px;
        }

        foreignObject h4{
            font-family: 'Franklin Gothic', sans-serif;
            font-size: 20px;
            text-align: center;
            text-transform: uppercase;
        }


        foreignObject p{
            font-family: 'Franklin Gothic', sans-serif;
            font-size: 15px;
            text-align: center;
            text-transform: uppercase;
        }

    </style>

    <link rel="stylesheet" href="style.css">
</head>

<body>

    <svg id="bubbles" height="600" width="1000"></svg>

    <div class="avatar_selector">
        <!-- <svg id="avatar_display" height="300" width="550"></svg> -->

        <div class="active analysts display">
            <!-- <h5>Analysts</h5> -->

            <div class="individual">
                <img class="analyst avatars" src="avatars/architect.png" width="150" height="150">
                <h6 style="text-align: center">INTJ</h6>
                <h6 style="text-align: center">Architect</h6>

            </div>
            <div class="individual">
                <img class="analyst avatars" src="avatars/logician.png" width="150" height="150">
                <h6 style="text-align: center">INTP</h6>
                <h6 style="text-align: center">Logician</h6>

            </div>
            <div class="individual">
                <img class="analyst avatars" src="avatars/commander.png" width="150" height="150">
                <h6 style="text-align: center">ENTJ</h6>
                <h6 style="text-align: center">Commander</h6>

            </div>
            <div class="individual">
                <img class="analyst avatars" src="avatars/debater.png" width="150" height="150">
                <h6 style="text-align: center">ENTP</h6>
                <h6 style="text-align: center">Debater</h6>

            </div>
        </div>

        <div class="hidden diplomats display">

            <!-- <h5>Diplomats</h5> -->
            <div class="individual">

                <img class="diplomats avatars" src="avatars/advocate.png" width="150" height="150">
                <h6 style="text-align: center">INFJ</h6>
                <h6 style="text-align: center">Advocate</h6>

            </div>
            <div class="individual">
                <img class="diplomats avatars" src="avatars/mediator.png" width="150" height="150">
                <h6 style="text-align: center">INFP</h6>
                <h6 style="text-align: center">Mediator</h6>

            </div>
            <div class="individual">
                <img class="diplomats avatars" src="avatars/protagonist.png" width="150" height="150">
                <h6 style="text-align: center">ENFJ</h6>
                <h6 style="text-align: center">Protagonist</h6>

            </div>
            <div class="individual">
                <img class="diplomats avatars" src="avatars/campaigner.png" width="150" height="150">
                <h6 style="text-align: center">ENFP</h6>
                <h6 style="text-align: center">Campaigner</h6>

            </div>
        </div>

        <div class="hidden sentinels display">
            <!-- <h5>Sentinels</h5> -->
            <div class="individual">
                <img class="sentinels avatars" src="avatars/logistician.png" width="150" height="150">
                <h6 style="text-align: center">ISTJ</h6>
                <h6 style="text-align: center">Logistician</h6>

            </div>
            <div class="individual">
                <img class="sentinels avatars" src="avatars/defender.png" width="150" height="150">
                <h6 style="text-align: center">ISFJ</h6>
                <h6 style="text-align: center">Defender</h6>

            </div>
            <div class="individual">
                <img class="sentinels avatars" src="avatars/executive.png" width="150" height="150">
                <h6 style="text-align: center">ESTJ</h6>
                <h6 style="text-align: center">Executive</h6>

            </div>
            <div class="individual">
                <img class="sentinels avatars" src="avatars/consul.png" width="150" height="150">
                <h6 style="text-align: center">ESFJ</h6>
                <h6 style="text-align: center">Consul</h6>

            </div>
        </div>

        <div class="hidden explorers display">
            <!-- <h5>Explorers</h5> -->
            <div class="individual">
                <img class="explorers avatars" src="avatars/virtuoso.png" width="150" height="150">
                <h6 style="text-align: center">ISTP</h6>
                <h6 style="text-align: center">Virtuoso</h6>

            </div>
            <div class="individual">
                <img class="explorers avatars" src="avatars/adventurer.png" width="150" height="150">
                <h6 style="text-align: center">ISFP</h6>
                <h6 style="text-align: center">Adventurer</h6>

            </div>
            <div class="individual">
                <img class="explorers avatars" src="avatars/entrepreneur.png" width="150" height="150">
                <h6 style="text-align: center">ESTP</h6>
                <h6 style="text-align: center">Entrepreneur</h6>

            </div>
            <div class="individual">
                <img class="explorers avatars" src="avatars/entertainer.png" width="150" height="150">
                <h6 style="text-align: center">ESFP</h6>
                <h6 style="text-align: center">Entrepreneur</h6>

            </div>
        </div>
        <div class='contains_triangle'>
            <img class='triangle' src="triangle.png" width="32" height="37">
        </div>
    </div>

    <svg id="enneagramSelector" height="600" width="600"></svg>

    <div>
        <svg id="barchart" height="800" width="800" style="margin:50px"></svg>
        <svg id="cards" height="400" width="800" style="margin:50px">

        </svg>
    </div>

    <script>

        const svg = d3.select("svg#barchart");
        const width = svg.attr("width");
        const height = svg.attr("height");
        const margin = { top: 10, right: 10, bottom: 50, left: 150 };
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        const bubblessvg = d3.select("svg#bubbles");
        const bubbleswidth = bubblessvg.attr("width");
        const bubblesheight = bubblessvg.attr("height");
        const bubblesmargin = { top: 10, right: 20, bottom: 10, left: 20 };
        const bubblesWidth = width - bubblesmargin.left - bubblesmargin.right;
        const bubblesHeight = height - bubblesmargin.top - bubblesmargin.bottom;
        let bubbleannotations = bubblessvg.append("g").attr("id", "bubblesannotations");

        let bubbleLayer = d3.select("#by-class").append("g");


        const getCompatibility = async function () {
            let data = await d3.csv("mbti_clean.csv", d3.autotype);
            console.log('data');
            console.log(data);
            let mbti_counts = await d3.csv("mbti_counts.csv", d3.autotype);

            let running_mbti = [];

            const counts = []
            const mbtis = []
            mbti_counts.forEach((d) => {
                counts.push(parseInt(d.count));
                mbtis.push(d.mbti);
            })

            const bubbleExtent = d3.extent(counts);
            const bubbleScale = d3.scaleLinear().domain(bubbleExtent).range([7, 55]);

            const mbtiScale = d3.scalePoint().domain(mbtis).range([50, 300]);

            var bubblecolorScale = d3.scaleOrdinal()
                .domain(mbtis)
                .range(d3.schemeSet1);

            var bubblenode = bubblessvg.append("g").selectAll("circle")
                .data(mbti_counts)
                .join("circle")
                .attr('cx', bubblesWidth / 2)
                .attr('cy', bubblesHeight / 2)
                .attr("fill", d => bubblecolorScale(d.mbti))
                .attr("stroke", "black")
                .style("stroke-width", 1)
                .attr('r', d => bubbleScale(d.count))
                .on("mouseover", function () { console.log(d => d.mbti) });

            bubblenode.append("g").append("text").text(d => d.mbti);




            var simulation = d3.forceSimulation()
                .force("center", d3.forceCenter().x(bubblesWidth / 2).y(bubblesHeight / 2)) // Attraction to the center of the svg area
                .force("charge", d3.forceManyBody().strength(.1)) // Nodes are attracted one each other of value is > 0
                .force("collide", d3.forceCollide().strength(.2).radius(function (d) { return (bubbleScale(d.count) + 3) }).iterations(1)) // Force that avoids circle overlapping

            simulation
                .nodes(mbti_counts)
                .on("tick", function (d) {
                    bubblenode
                        .attr("cx", function (d) { return d.x; })
                        .attr("cy", function (d) { return d.y; })
                });


            // let circles = enneagramSelector.selectAll('g.circleNodes').data(nodes)
            //     .join('g')
            //     .attr('class', 'circleNode')
            //     .attr('transform', d => `rotate(${d.degree},${origin},${origin})`)

            // nodeCircles = circles.append('circle')
            //     // SOURCE: drawing circles around a circle
            //     // https://spin.atomicobject.com/2015/06/12/objects-around-svg-circle-d3-js/
            //     .attr('class', 'circle.node')
            //     .join('circle')
            //     .attr('r', 25)
            //     .attr('fill', d => d.color)
            //     .attr('cx', d => d.x)
            //     .attr('cy', d => d.y)
            //     .attr('id', d => d.nodeID);
            // // .attr('transform', d => `rotate(${d.degree},${origin},${origin})`);

            // nodeLabels = circles
            //     .append('text')
            //     .text(d => d.nodeID)
            //     .attr('text-anchor', 'middle')
            //     .attr('alignment-baseline', 'middle')
            //     .style('font-size', '25px')
            //     .attr('fill', 'white')
            //     .attr('x', origin + (radius * Math.sin(0)))
            //     .attr('y', origin - (radius * Math.cos(0)))
            // console.log(counts);

            d3.select(".triangle")
                .on('click', changeAvatars);

            function changeAvatars() {
                if (d3.selectAll(".analysts").classed("active")) {

                    d3.selectAll(".analysts")
                        .classed("active", false);
                    d3.selectAll(".analysts")
                        .classed("hidden", true);

                    d3.selectAll(".diplomats")
                        .classed("active", true);
                    d3.selectAll(".diplomats")
                        .classed("hidden", false);
                }


                else if (d3.selectAll(".diplomats").classed("active")) {

                    d3.selectAll(".diplomats")
                        .classed("active", false);
                    d3.selectAll(".diplomats")
                        .classed("hidden", true);

                    d3.selectAll(".sentinels")
                        .classed("active", true);
                    d3.selectAll(".sentinels")
                        .classed("hidden", false);
                }

                else if (d3.selectAll(".sentinels").classed("active")) {

                    d3.selectAll(".sentinels")
                        .classed("active", false);
                    d3.selectAll(".sentinels")
                        .classed("hidden", true);

                    d3.selectAll(".explorers")
                        .classed("active", true);
                    d3.selectAll(".explorers")
                        .classed("hidden", false);
                }

                else if (d3.selectAll(".explorers").classed("active")) {

                    d3.selectAll(".explorers")
                        .classed("active", false);
                    d3.selectAll(".explorers")
                        .classed("hidden", true);

                    d3.selectAll(".analysts")
                        .classed("active", true);
                    d3.selectAll(".analysts")
                        .classed("hidden", false);
                }
            }


            d3.selectAll(".individual").classed('border', false)
                .on("click", chooseMBTI)
                .on("mouseover", function () {
                    let border = d3.select(this)
                    border.style('border', '3px solid rgb(190, 190, 190)')
                })
                .on("mouseout", function () {
                    let border = d3.select(this)
                    let borderClass = border.classed('border')
                    // console.log(borderClass)
                    if (!borderClass) {
                        border.style('border', '3px solid transparent')
                    }
                })

            function chooseMBTI() {

                //estelle is trying to change the border on click 
                d3.selectAll(".individual").style('border', '3px solid transparent').classed('border', false);

                // d3.selectAll(".individual:hover").style('border','rgb(190, 190, 190)');
                let border = d3.select(this);
                border.style('border', '3px solid rgb(190, 190, 190)');
                let borderClass = border.classed('border', true)


                running_mbti = d3.select(this).select(".individual h6").text();



                mbtiBars(getCharacterInfo(running_mbti, false));
            }

            let graphNamesG = [];


            // getCharacterInfo is a function that returns an 
            function getCharacterInfo(input_mbti, enneagramselected) {
                // let input_mbti = input_mbti;



                // new object array compat contains mbti, role, movie and a compat score (0-4) based on mbti similarity
                var compat = [];

                // loop through each character
                for (let x = 0; x < data.length; x++) {

                    // reset compatibility count to 0 for each new character
                    count = 0;

                    // loop through mbti of each character
                    for (let i = 0; i < 4; i++) {

                        // get a count for compatibility
                        if (input_mbti.charAt(i) === data[x]['mbti'].charAt(i)) {
                            count += 1;
                        }
                    }

                    // create array of character name, movie title, and compatibility
                    // push to object array

                    let info = [data[x]['mbti'], data[x]['enneagram'], data[x]['role'], data[x]['movie'], count, data[x]['img_filepath']];
                    compat.push(info);

                }



                // console.log(compat);

                function getRandomCharacter(arr) {
                    const randomIndex = Math.floor(Math.random() * arr.length);
                    let character = arr[randomIndex];
                    return character;
                }

                // get random characters from each compat score

                // new arrays for each of the different compat scores
                compat0 = [];
                compat25 = [];
                compat50 = [];
                compat75 = [];
                compat100 = [];

                for (let x = 0; x < compat.length; x++) {
                    if (compat[x]['4'] === 0) {
                        compat[x].push('0%');
                        compat0.push(compat[x]);
                    }
                    else if (compat[x]['4'] === 1) {
                        compat[x].push('25%');
                        compat25.push(compat[x]);
                    }
                    else if (compat[x]['4'] === 2) {
                        compat[x].push('50%');
                        compat50.push(compat[x]);
                    }
                    else if (compat[x]['4'] === 3) {
                        compat[x].push('75%');
                        compat75.push(compat[x]);
                    }
                    else if (compat[x]['4'] === 4) {
                        compat[x].push('100%');
                        compat100.push(compat[x]);
                    }
                }

                console.log('compat');
                console.log(compat);


                //console.log(compat100.length);

                //hist_counts contains counts the number of characters in each compatability bracket. To be used in the histogram.
                const hist_counts = []

                hist_counts.push(['all letters in common', compat100.length]);
                hist_counts.push(['3 letters in common', compat75.length]);
                hist_counts.push(['2 letters in common', compat50.length]);
                hist_counts.push(['1 letter in common', compat25.length]);
                hist_counts.push(['no letters in common', compat0.length]);

                // graphNames contains one random character from each mbti compat

                var graphNames = [];
                graphNames.push(getRandomCharacter(compat0));
                graphNames.push(getRandomCharacter(compat25));
                graphNames.push(getRandomCharacter(compat50));
                graphNames.push(getRandomCharacter(compat75));
                graphNames.push(getRandomCharacter(compat100));


                console.log('graphNames');
                console.log(graphNames);

                graphNamesG = graphNames;


                // return graphNames;

                return hist_counts


            }


            // making bar chart
            let annotations = svg.append("g").attr("id", "annotations");
            let chartArea = svg.append("g").attr("id", "points")
                .attr("transform", `translate(${margin.left},${margin.top})`);


            // intial left axis and gridlines, leave it to update later

            leftAxisScale = d3.scaleBand().domain(["no letters in common",
                "1 letter in common",
                "2 letters in common",
                "3 letters in common",
                "all letters in common"]).range([chartHeight, 0]).padding(0.05);


            let leftAxis = d3.axisLeft(leftAxisScale);
            annotations.append("g")
                .attr("class", "y axis")
                .call(leftAxis)
                .attr("transform", `translate(${margin.left - 1}, ${margin.top})`);

            // initial bottom axis and gridlines because these don't change           
            // const rankScale = d3.scaleLinear().domain([0, 4]).range([0, chartWidth]);

            // let bottomAxis = d3.axisBottom(rankScale).ticks(4);
            // // maybe get rid of this laters
            // let bottomAxisG = d3.axisBottom(rankScale).tickSize(-chartHeight - 10).tickFormat("").ticks(4);

            let bottomAxis = d3.axisBottom();
            let bottomAxisG = annotations.append("g")
                .attr("class", "x axis")
                .attr("transform", `translate(${margin.left - 1},${chartHeight + margin.top})`)


            // annotations.append("g")
            //     .attr("class", "x axis")
            //     .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
            //     .call(bottomAxis);

            // annotations.append("g")
            //     .attr("class", "x gridlines")
            //     .attr("transform", `translate(${margin.left}, ${chartHeight + margin.top + 10})`)
            //     .call(bottomAxisG);


            function mbtiBars(alist) {

                // const characterScale = d3.scaleBand().domain(topRandomCharactersNames).range([chartHeight, 0])
                //     .padding(0.05);

                // console.log(graphNames);
                // chartArea.selectAll('rect.bar').data(graphNames)
                //     .join('rect')
                //     .attr('class', 'bar')
                //     .attr("fill", "steelblue")
                //     .attr("x", d => rankScale(0))
                //     .attr("y", d => leftAxisScale(d[5]))
                //     .attr("height", leftAxisScale.bandwidth())
                //     .attr("width", d => rankScale(d[4])-rankScale(0))
                //     .attr("opacity", 0.9);

                console.log('alist');
                console.log(alist);

                const values = []
                alist.forEach((d) => {
                    values.push(d[1])
                })

                console.log('values');
                console.log(values);

                const histExtent = d3.extent(values)

                console.log('hist extent');
                console.log(histExtent);
                const histScale = d3.scaleLinear().domain([0, histExtent[1]]).range([0, chartWidth]);

                bottomAxis.scale(histScale)
                bottomAxisG.transition().call(bottomAxis);


                chartArea.selectAll('rect.bar').data(alist)
                    .join(enter => enter.append('rect')
                        .attr('class', 'bar')
                        .attr("fill", barChartColor(running_mbti))
                        .attr("x", d => histScale(0))
                        .attr("y", d => leftAxisScale(d[0]))
                        .attr("height", leftAxisScale.bandwidth())
                        .attr("width", d => histScale(d[1]) - histScale(0))
                        .attr("opacity", 0)
                        .call(enter => enter.transition()
                            .attr('opacity', 1)),
                        update => update.call(update => update.transition()  // Animate resizing and movement
                            .attr("fill", barChartColor(running_mbti))
                            .attr("x", d => histScale(0))
                            .attr("y", d => leftAxisScale(d[0]))
                            .attr("height", leftAxisScale.bandwidth())
                            .attr("width", d => histScale(d[1]) - histScale(0))),
                        exit => exit.call(exit => exit.transition().attr('opacity', 0).remove()));


                // creating the character cards

                // card svg has a width of 800, each card should be 140px with 25px margins between each card
                const card = d3.select("svg#cards");


                // loop through randomnames, make a card for each char
                var i = 0;

                for (x = 0; x < graphNamesG.length; x++) {
                    var fo = card.append('foreignObject')
                        .attr("width", 140)
                        .attr("height", 300)
                        .attr("x", 0 + i)
                        .attr("y", 0);

                    var div = fo.append('xhtml:div')
                        .attr("transform", `translate(${margin.left},${margin.top})`)
                        .attr("class", "divcard");

                    div.append("img").attr("src", 'triangle.png').attr("width", "100%");
                    div.append("h4").html(graphNamesG[x]['2']);
                    div.append("p").html(graphNamesG[x]['3']);

                    console.log(i);
                    i = i + 160;
                }







            }

            function barChartColor(mbti) {
                analysts = ["INTJ", "INTP", "ENTJ", "ENTP"]
                diplomats = ["INFJ", "INFP", "ENFJ", "ENFP"]
                sentinels = ["ISTJ", "ISFJ", "ESTJ", "ESFJ"]
                explorers = ["ISTP", "ISFP", "ESTP", "ESFP"]
                if (analysts.includes(mbti)) {
                    return "rgb(149,98,123)"
                }
                if (diplomats.includes(mbti)) {
                    return "rgb(153,194,108)"
                }
                if (sentinels.includes(mbti)) {
                    return "rgb(139,223,220)"
                }
                if (explorers.includes(mbti)) {
                    return "rgb(228,199,40)"
                }

            }


            let origin = 300;
            let radius = 150;
            const enneagramSelector = d3.select("svg#enneagramSelector").append('g');
            enneagramSelector.append("circle")
                .attr("cx", origin)
                .attr('cy', origin)
                .attr('r', radius)
                .attr('stroke', 'none')
                .attr('fill', 'none');
            // let nodes = {"1":0, "2":40, "3":80, "4":120, "5":160, "6":200, "7":240, "8":280, "9":320}

            let nodeIDs = [9, 1, 2, 3, 4, 5, 6, 7, 8];
            let nodeDegree = [0, 40, 80, 120, 160, 200, 240, 280, 320];
            let nodeColor = ['#27749C', '#2FB478', '#6DCD38', '#E6C742', '#FF4C58', '#F856BD', '#D460F1', '#886AEA', '#7399E4', '#7CD4DD']
            // nodes = nodes.map(x=>{node:x})
            // const nodes = nodeID.map((x, i)=> ({}))
            nodes = []
            for (let i = 0; i < nodeIDs.length; i++) {
                dict = { nodeID: nodeIDs[i], degree: nodeDegree[i], color: nodeColor[i] };
                nodes.push(dict);
            }

            links = []
            sources = [9, 9, 3, 1, 1, 2, 2, 5, 5]
            targets = [3, 6, 6, 4, 7, 8, 4, 8, 7]
            // labels = ['Peacemaker','Reformer','Helper','Achiever','Individualist','Investigator','Loyalist','Enthusiast','Challenger','Peacemaker']

            for (let i = 0; i < sources.length; i++) {
                dict = { source: sources[i], target: targets[i] };
                links.push(dict);
            }

            console.log('nodes', nodes)
            console.log('links', links)

            nodes.forEach(d => {
                d.x = origin + (radius * Math.sin(0));
                d.y = origin - (radius * Math.cos(0));

            })

            var simEnneagram = d3.forceSimulation()
                .nodes(nodes)
                .force("links", d3.forceLink()
                    .links(links)
                    .id(d => d['nodeID']))
                .stop()


            // var linkGen = d3.linkHorizontal()
            //                 .source(function(d){
            //                     return(d.source)
            //                 })

            // var enneagramSelectorAnnotations = enneagramSelector.append('g');

            let circles = enneagramSelector.selectAll('g.circleNodes').data(nodes)
                .join('g')
                .attr('class', 'circleNode')
                .attr('transform', d => `rotate(${d.degree},${origin},${origin})`)

            nodeCircles = circles.append('circle')
                // SOURCE: drawing circles around a circle
                // https://spin.atomicobject.com/2015/06/12/objects-around-svg-circle-d3-js/
                .attr('class', 'circle.node')
                .join('circle')
                .attr('r', 25)
                .attr('fill', d => d.color)
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('id', d => d.nodeID);
            // .attr('transform', d => `rotate(${d.degree},${origin},${origin})`);

            console.log('sdkjfl')
            console.log(links)
            let lines = enneagramSelector.selectAll("link").data(links)
                .append('line')
                .attr("class", "link")
                .style("stroke", "black")
                .attr('stroke-width', 4)
                .attr("x1", d => d.source.x).attr("x2", d => d.target.x)
                .attr("y1", d => d.source.y).attr("y2", d => d.target.y);



            nodeLabels = circles
                .append('text')
                .text(d => d.nodeID)
                .attr('text-anchor', 'middle')
                .attr('alignment-baseline', 'middle')
                .style('font-size', '25px')
                .attr('fill', 'white')
                .attr('x', origin + (radius * Math.sin(0)))
                .attr('y', origin - (radius * Math.cos(0)))

            nodeCircles
                .classed('outline', false)
                .on('mouseover', function () {
                    let enn = d3.select(this);
                    // console.log(enn);
                    enn.transition().duration(100)
                        .attr("stroke-width", 7)
                        .style("stroke-opacity", .6)
                        .style("stroke", 'black')
                })
                .on('mouseout', function () {
                    let enn = d3.select(this);
                    let ennOutline = enn.classed('outline');
                    if (!ennOutline) {
                        // console.log(enn);
                        enn.transition().duration(200)
                            .attr("stroke-width", 0)
                    }

                })
                .on('click', function () {
                    nodeCircles.attr('stroke-width', 0).classed('outline', false);
                    let enn = d3.select(this);
                    enn.attr('stroke-width', 7).style('stroke-opacity', .6)
                    let ennID = enn.node().id;

                    console.log(ennID);
                    enn.attr('stroke', 'black')

                    console.log(running_mbti);

                    enn.classed('outline', true);


                    //if the second parameter to getCharacterInfo is true, we use running compat in the getcharacterinfo function
                    // mbti_bars(getCharacterInfo(running_mbti,true))
                    ;
                })

            // console.log(links);



            // const link = d3.linkHorizontal()({
            //     source: nodes[0],
            //     target: nodes[1]
            // });


            // linksG = enneagramSelector.append('path')
            //     .attr('d', links[0])


        }


        getCompatibility();


    </script>
</body>

</html>